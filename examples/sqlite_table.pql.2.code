#!/usr/bin/perl
#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# vim: syntax=perl ts=4 sw=4
#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#Generated By: pequel Version 2.3-6, Build: Wednesday October  26 23:16:49 BST 2005
#            : http://sourceforge.net/projects/pequel/
#Script Name : examples/sqlite_table.pql
#Created On  : Wed Oct 26 14:11:23 2005
#Perl Version: /usr/bin/perl 5.6.1 on solaris
#For         : 
#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#Options:
#prefix(examples) directory pathname prefix.
#dumpcode(1) Dump the generated Perl code for pequel script
#noverbose(1) do not progress counter
#script_name(examples/sqlite_table.pql) script filename
#header(1) write header record to output.
#optimize(1) optimize generated code.
#doc_title(Sqlite Tables Example Script) document title.
#doc_email(sample@youraddress.com) document email entry.
#doc_version(2.2) document version for pequel script.
#inline_cc(CC) Inline: CC
#inline_force_build(1) Inline: force_build
#inline_optimize(-xO5 -xinline=%auto) Inline: OPTIMIZE
#inline_ccflags(-xchip=ultra3 -DSS_64BIT_SERVER -DBIT64 -DMACHINE64) Inline: CCFLAGS
#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
use strict;
use Fcntl;
use constant _I_PRODUCT_CODE         => int    0;
use constant _I_COST_PRICE           => int    1;
use constant _I_DESCRIPTION          => int    2;
use constant _I_SALES_CODE           => int    3;
use constant _I_SALES_PRICE          => int    4;
use constant _I_SALES_QTY            => int    5;
use constant _I_SALES_DATE           => int    6;
use constant _I_LOCATION             => int    7;
use constant _I_S1_DESCRIPTION       => int    8;
use constant _I_S1_LOCATION          => int    9;
use constant _I_S2_DESCRIPTION       => int   10;
use constant _I_S2_LOCATION          => int   11;
use constant _O_PRODUCT_CODE         => int    1;
use constant _O_RECORD_COUNT         => int    2;
use constant _O_SALES_QTY_SAMPLE1    => int    3;
use constant _O_S1_DESCRIPTION       => int    4;
use constant _O_S1_LOCATION          => int    5;
use constant _O_SALES_QTY_SAMPLE2    => int    6;
use constant _O_S2_DESCRIPTION       => int    7;
use constant _O_S2_LOCATION          => int    8;
use constant _T_SAMPLE2_FLD_DESCRIPTION   => int    0;
use constant _T_SAMPLE2_FLD_LOCATION      => int    1;
use constant _T_SAMPLE1_FLD_DESCRIPTION   => int    0;
use constant _T_SAMPLE1_FLD_LOCATION      => int    1;
use constant _I_SAMPLE1_PRODUCT_CODE_FLD_KEY          => int   12;
use constant _I_SAMPLE1_PRODUCT_CODE_FLD_DESCRIPTION  => int   13;
use constant _I_SAMPLE1_PRODUCT_CODE_FLD_LOCATION     => int   14;
use constant _I_SAMPLE2_PRODUCT_CODE_FLD_KEY          => int   15;
use constant _I_SAMPLE2_PRODUCT_CODE_FLD_DESCRIPTION  => int   16;
use constant _I_SAMPLE2_PRODUCT_CODE_FLD_LOCATION     => int   17;
local $\="\n";
local $,="|";
use constant LAST_ICELL => int 11;
my @I_VAL;
my @O_VAL;
my $key__I_PRODUCT_CODE;
my $previous_key__I_PRODUCT_CODE = undef;
foreach my $f (1..8) { $O_VAL[$f] = undef; }
&LoadTableSAMPLE2; # Create database for SAMPLE2
&LoadTableSAMPLE1; # Create database for SAMPLE1
# Sort:PRODUCT_CODE(asc:string) 
open(DATA, q{cat  - | sort  -t'|' -y -k 1,1 2>/dev/null |}) || die "Cannot open input: $!";
my $fd = fileno(DATA);
OpenSortStream($fd);
&PrintHeader();
SqliteConnect($fd);
my $i;
while (readsplit(\@I_VAL))
{
    ++$i;
    $key__I_PRODUCT_CODE = $I_VAL[_I_PRODUCT_CODE];
    if (!defined($previous_key__I_PRODUCT_CODE))
    {
        $previous_key__I_PRODUCT_CODE = $key__I_PRODUCT_CODE;
    }
    
    elsif ($previous_key__I_PRODUCT_CODE ne $key__I_PRODUCT_CODE)
    {
        print STDOUT
            $O_VAL[_O_PRODUCT_CODE],
            $O_VAL[_O_RECORD_COUNT],
            $O_VAL[_O_SALES_QTY_SAMPLE1],
            $O_VAL[_O_S1_DESCRIPTION],
            $O_VAL[_O_S1_LOCATION],
            $O_VAL[_O_SALES_QTY_SAMPLE2],
            $O_VAL[_O_S2_DESCRIPTION],
            $O_VAL[_O_S2_LOCATION]
        ;
        $previous_key__I_PRODUCT_CODE = $key__I_PRODUCT_CODE;
        @O_VAL = undef;
    }
    
    $O_VAL[_O_PRODUCT_CODE] = $I_VAL[_I_PRODUCT_CODE];
    $O_VAL[_O_RECORD_COUNT]++;
    $I_VAL[_I_S1_DESCRIPTION] = $I_VAL[_I_SAMPLE1_PRODUCT_CODE_FLD_DESCRIPTION];
    $O_VAL[_O_S1_DESCRIPTION] = $I_VAL[_I_S1_DESCRIPTION];
    $I_VAL[_I_S1_LOCATION] = $I_VAL[_I_SAMPLE1_PRODUCT_CODE_FLD_LOCATION];
    $O_VAL[_O_S1_LOCATION] = $I_VAL[_I_S1_LOCATION];
    $I_VAL[_I_S2_DESCRIPTION] = $I_VAL[_I_SAMPLE2_PRODUCT_CODE_FLD_DESCRIPTION];
    $O_VAL[_O_S2_DESCRIPTION] = $I_VAL[_I_S2_DESCRIPTION];
    $I_VAL[_I_S2_LOCATION] = $I_VAL[_I_SAMPLE2_PRODUCT_CODE_FLD_LOCATION];
    $O_VAL[_O_S2_LOCATION] = $I_VAL[_I_S2_LOCATION];
    
    if (exists $I_VAL[_I_SAMPLE1_PRODUCT_CODE_FLD_KEY] ne '') {
        $O_VAL[_O_SALES_QTY_SAMPLE1] += $I_VAL[_I_SALES_QTY] unless ($I_VAL[_I_SALES_QTY] eq '');
    }
    
    if (exists $I_VAL[_I_SAMPLE2_PRODUCT_CODE_FLD_KEY] ne '') {
        $O_VAL[_O_SALES_QTY_SAMPLE2] += $I_VAL[_I_SALES_QTY] unless ($I_VAL[_I_SALES_QTY] eq '');
    }
}

print STDOUT
    $O_VAL[_O_PRODUCT_CODE],
    $O_VAL[_O_RECORD_COUNT],
    $O_VAL[_O_SALES_QTY_SAMPLE1],
    $O_VAL[_O_S1_DESCRIPTION],
    $O_VAL[_O_S1_LOCATION],
    $O_VAL[_O_SALES_QTY_SAMPLE2],
    $O_VAL[_O_S2_DESCRIPTION],
    $O_VAL[_O_S2_LOCATION]
;
SqliteDisconnect();
#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#++++++ Table SAMPLE1 --> Type :Pequel::Type::Table::Sqlite ++++++
sub LoadTableSAMPLE1
{
    my %_TABLE_SAMPLE1;
    my $exists = (-e "examples/_TABLE_SAMPLE1.sqlt");
    use DBI;
    my $dbh = DBI->connect
    (
        "dbi:SQLite:dbname=examples/_TABLE_SAMPLE1.sqlt", '', '', 
        { RowCacheSize => 5000, RaiseError => 0, AutoCommit => 0 }
    )
    
    or die "Cannot open examples/_TABLE_SAMPLE1.sqlt:$!";
    $dbh->{PrintError} = 0;
    $dbh->do("PRAGMA synchronous=OFF");
    $dbh->do("PRAGMA count_changes=OFF");
    $dbh->do("PRAGMA full_column_names=OFF");
    my $sqlite = $dbh->{sqlite_version};
    if (!$exists)
    {
        my @flist =
        (
            'key',
            'description',
            'location'
        );
        
        my %flist =
        (
            key => 'VARCHAR NOT NULL PRIMARY KEY',
            description => 'varchar',
            location => 'varchar'
        );
        
        $dbh->do("CREATE TABLE SAMPLE1 ( @{[ join(',', map(qq{$_ $flist{$_}}, @flist)) ]} )");
        $dbh->commit;
        open(SAMPLE1, "sort  -u -t'|' -k 1 sample.data |");
        $dbh->do("BEGIN;");
        my $sth = $dbh->prepare("INSERT INTO SAMPLE1 ( @{[ join(', ', @flist) ]} ) VALUES( @{[ join(', ', map('?', @flist)) ]} )");
        while (<SAMPLE1>)
        {
            chomp;
            my (@flds) = split("[|]", $_, -1);
            $sth->execute($flds[0], @flds[ 2,7 ]);
        }
        
        close(SAMPLE1);
        $sth->finish;
        $dbh->commit;
    }
    
}

#++++++ Table SAMPLE2 --> Type :Pequel::Type::Table::Sqlite::Merge ++++++
sub LoadTableSAMPLE2
{
    my %_TABLE_SAMPLE2;
    my $exists = (-e "examples/_TABLE_SAMPLE2.sqlt");
    use DBI;
    my $dbh = DBI->connect
    (
        "dbi:SQLite:dbname=examples/_TABLE_SAMPLE2.sqlt", '', '', 
        { RowCacheSize => 5000, RaiseError => 0, AutoCommit => 0 }
    )
    
    or die "Cannot open examples/_TABLE_SAMPLE2.sqlt:$!";
    $dbh->{PrintError} = 0;
    $dbh->do("PRAGMA synchronous=OFF");
    $dbh->do("PRAGMA count_changes=OFF");
    $dbh->do("PRAGMA full_column_names=OFF");
    my $sqlite = $dbh->{sqlite_version};
    if (!$exists)
    {
        my @flist =
        (
            'key',
            'description',
            'location'
        );
        
        my %flist =
        (
            key => 'VARCHAR NOT NULL PRIMARY KEY',
            description => 'varchar',
            location => 'varchar'
        );
        
        $dbh->do("CREATE TABLE SAMPLE2 ( @{[ join(',', map(qq{$_ $flist{$_}}, @flist)) ]} )");
        $dbh->commit;
        open(SAMPLE2, "sort  -u -t'|' -k 1 sample.data |");
        $dbh->do("BEGIN;");
        my $sth = $dbh->prepare("INSERT INTO SAMPLE2 ( @{[ join(', ', @flist) ]} ) VALUES( @{[ join(', ', map('?', @flist)) ]} )");
        while (<SAMPLE2>)
        {
            chomp;
            my (@flds) = split("[|]", $_, -1);
            $sth->execute($flds[0], @flds[ 2,7 ]);
        }
        
        close(SAMPLE2);
        $sth->finish;
        $dbh->commit;
    }
    
}

sub PrintHeader
{
    local $\="\n";
    local $,="|";
    print 
        'PRODUCT_CODE',
        'RECORD_COUNT',
        'SALES_QTY_SAMPLE1',
        'S1_DESCRIPTION',
        'S1_LOCATION',
        'SALES_QTY_SAMPLE2',
        'S2_DESCRIPTION',
        'S2_LOCATION'
        ;
}

#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#***** I N L I N E *****
use Inline
    C => Config =>
    NAME => 'examples::sqlite_table',
    CC => 'CC',
    CLEAN_AFTER_BUILD => '1',
    CLEAN_BUILD_AREA => '1',
    PRINT_INFO => '0',
    BUILD_NOISY => '0',
    BUILD_TIMERS => '0',
    FORCE_BUILD => '1',
    LIBS => '  -L/bld/.libs -lpthread -lexc -lsqlite',
    INC => '  -I/bld -I/src',
    CCFLAGS => '-xchip=ultra3 -DSS_64BIT_SERVER -DBIT64 -DMACHINE64  -DNDEBUG=1',
    OPTIMIZE => '-xO5 -xinline=%auto  '
    ;

use Inline C => q~

#include "sqlite.h"
#include "sqliteInt.h"

#define GFMAXPIPBUFFER      3072
#define GFMAXPIPFLDS        13

#define _I_PRODUCT_CODE            0
#define _I_COST_PRICE              1
#define _I_DESCRIPTION             2
#define _I_SALES_CODE              3
#define _I_SALES_PRICE             4
#define _I_SALES_QTY               5
#define _I_SALES_DATE              6
#define _I_LOCATION                7
#define _I_S1_DESCRIPTION          8
#define _I_S1_LOCATION             9
#define _I_S2_DESCRIPTION         10
#define _I_S2_LOCATION            11

#define _I_SAMPLE1_PRODUCT_CODE_FLD_KEY            12
#define _I_SAMPLE1_PRODUCT_CODE_FLD_DESCRIPTION    13
#define _I_SAMPLE1_PRODUCT_CODE_FLD_LOCATION       14
#define _I_SAMPLE2_PRODUCT_CODE_FLD_KEY            15
#define _I_SAMPLE2_PRODUCT_CODE_FLD_DESCRIPTION    16
#define _I_SAMPLE2_PRODUCT_CODE_FLD_LOCATION       17

static sqlite *db_SAMPLE2 = 0;
sqlite_vm *ppVm_SAMPLE2_PRODUCT_CODE;

static sqlite *db_SAMPLE1 = 0;
sqlite_vm *ppVm_SAMPLE1_PRODUCT_CODE;


int sqlite_open_all();
int sqlite_pragma_all();
int sqlite_prep_all();

static const char *fields[GFMAXPIPFLDS];
static FILE *fstream = (FILE*)0;

sqlite *sqlite_open_db (char *DbFilename)
{

    sqlite *db = 0;

    if ( !sqliteOsFileExists(DbFilename) )
    {
        fprintf(stderr,"Database %s does not exist\n", DbFilename);
        return 0;
    }
    char *zErrMsg = 0;
    if ((db = sqlite_open(DbFilename, 0666, &zErrMsg)) == 0)
    {
        if ((db = sqlite_open(DbFilename, 0444, &zErrMsg)) == 0)
        {
            if ( zErrMsg )
            {
                fprintf(stderr,"Unable to open database %s: %s\n", DbFilename, zErrMsg);
                freemem(zErrMsg);
            }
            else
            {
                fprintf(stderr,"Unable to open database %s\n", DbFilename);
            }
            return 0;
        }
        else
        {
            fprintf(stderr,"Database %s opened READ ONLY!\n", DbFilename);
        }
    }
    return db;
		
}
int SqliteConnect (int fd)
{
    sqlite_open_all();
    sqlite_pragma_all();
    sqlite_prep_all();
    fstream = fdopen(fd, "r");
    return 1;
}

int sqlite_open_all ()
{
    char *pzErrMsg = 0;
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//++++++ Table SAMPLE2 --> Type :Pequel::Type::Table::Sqlite::Merge ++++++
    if ((db_SAMPLE2 = sqlite_open_db("examples/_TABLE_SAMPLE2.sqlt")) == 0)
    {
        return 0;
    }
    
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//++++++ Table SAMPLE1 --> Type :Pequel::Type::Table::Sqlite ++++++
    if ((db_SAMPLE1 = sqlite_open_db("examples/_TABLE_SAMPLE1.sqlt")) == 0)
    {
        return 0;
    }
    
    return 1;
}

int sqlite_pragma_all ()
{
    char *pzErrMsg = 0;
    register int ret;
//++++++ Table SAMPLE2 --> Type :Pequel::Type::Table::Sqlite::Merge ++++++
    if ((ret = sqlite_exec(db_SAMPLE2, "PRAGMA count_changes = OFF;", 0, 0, &pzErrMsg)) != SQLITE_OK)
    {
        fprintf(stderr, "** db_SAMPLE2: Cannot execute PRAGMA count_changes=OFF (%d-%s)\n", ret, pzErrMsg);
        freemem(pzErrMsg);
        return 0;
    }
    
    if ((ret = sqlite_exec(db_SAMPLE2, "PRAGMA empty_result_callbacks = OFF;", 0, 0, &pzErrMsg)) != SQLITE_OK)
    {
        fprintf(stderr, "** db_SAMPLE2: Cannot execute PRAGMA empty_result_callbacks=OFF (%d-%s)\n", ret, pzErrMsg);
        freemem(pzErrMsg);
        return 0;
    }
    
    if ((ret = sqlite_exec(db_SAMPLE2, "PRAGMA full_column_names = OFF;", 0, 0, &pzErrMsg)) != SQLITE_OK)
    {
        fprintf(stderr, "** db_SAMPLE2: Cannot execute PRAGMA full_column_names=OFF (%d-%s)\n", ret, pzErrMsg);
        freemem(pzErrMsg);
        return 0;
    }
    
    if ((ret = sqlite_exec(db_SAMPLE2, "PRAGMA show_datatypes = OFF;", 0, 0, &pzErrMsg)) != SQLITE_OK)
    {
        fprintf(stderr, "** db_SAMPLE2: Cannot execute PRAGMA show_datatypes=OFF (%d-%s)\n", ret, pzErrMsg);
        freemem(pzErrMsg);
        return 0;
    }
    
    if ((ret = sqlite_exec(db_SAMPLE2, "PRAGMA synchronous = OFF;", 0, 0, &pzErrMsg)) != SQLITE_OK)
    {
        fprintf(stderr, "** db_SAMPLE2: Cannot execute PRAGMA synchronous=OFF (%d-%s)\n", ret, pzErrMsg);
        freemem(pzErrMsg);
        return 0;
    }
    
//++++++ Table SAMPLE1 --> Type :Pequel::Type::Table::Sqlite ++++++
    if ((ret = sqlite_exec(db_SAMPLE1, "PRAGMA count_changes = OFF;", 0, 0, &pzErrMsg)) != SQLITE_OK)
    {
        fprintf(stderr, "** db_SAMPLE1: Cannot execute PRAGMA count_changes=OFF (%d-%s)\n", ret, pzErrMsg);
        freemem(pzErrMsg);
        return 0;
    }
    
    if ((ret = sqlite_exec(db_SAMPLE1, "PRAGMA empty_result_callbacks = OFF;", 0, 0, &pzErrMsg)) != SQLITE_OK)
    {
        fprintf(stderr, "** db_SAMPLE1: Cannot execute PRAGMA empty_result_callbacks=OFF (%d-%s)\n", ret, pzErrMsg);
        freemem(pzErrMsg);
        return 0;
    }
    
    if ((ret = sqlite_exec(db_SAMPLE1, "PRAGMA full_column_names = OFF;", 0, 0, &pzErrMsg)) != SQLITE_OK)
    {
        fprintf(stderr, "** db_SAMPLE1: Cannot execute PRAGMA full_column_names=OFF (%d-%s)\n", ret, pzErrMsg);
        freemem(pzErrMsg);
        return 0;
    }
    
    if ((ret = sqlite_exec(db_SAMPLE1, "PRAGMA show_datatypes = OFF;", 0, 0, &pzErrMsg)) != SQLITE_OK)
    {
        fprintf(stderr, "** db_SAMPLE1: Cannot execute PRAGMA show_datatypes=OFF (%d-%s)\n", ret, pzErrMsg);
        freemem(pzErrMsg);
        return 0;
    }
    
    if ((ret = sqlite_exec(db_SAMPLE1, "PRAGMA synchronous = OFF;", 0, 0, &pzErrMsg)) != SQLITE_OK)
    {
        fprintf(stderr, "** db_SAMPLE1: Cannot execute PRAGMA synchronous=OFF (%d-%s)\n", ret, pzErrMsg);
        freemem(pzErrMsg);
        return 0;
    }
    
    return 1;
}

int sqlite_prep_all ()
{
    char *pzErrMsg = 0;
    char sql[4096];
    register int ret;
//++++++ Table SAMPLE2 --> Type :Pequel::Type::Table::Sqlite::Merge ++++++
    if ((ret = sqlite_exec(db_SAMPLE2, "BEGIN TRANSACTION ON CONFLICT ABORT;", 0, 0, &pzErrMsg)) != SQLITE_OK)
    {
        fprintf(stderr, "** db_SAMPLE2: Cannot execute BEGIN statement (%d-%s)\n", ret, pzErrMsg);
        freemem(pzErrMsg);
        return 0;
    }
    
    sprintf(sql, "select key, description, location from SAMPLE2 order by key");
    if (sqlite_compile(db_SAMPLE2, sql, 0, &ppVm_SAMPLE2_PRODUCT_CODE, &pzErrMsg) != SQLITE_OK)
    {
        fprintf(stderr, "** Error compiling sql for db_SAMPLE2->SAMPLE2_PRODUCT_CODE (%s)\n", pzErrMsg);
        return 0;
    }
    
//++++++ Table SAMPLE1 --> Type :Pequel::Type::Table::Sqlite ++++++
    if ((ret = sqlite_exec(db_SAMPLE1, "BEGIN TRANSACTION ON CONFLICT ABORT;", 0, 0, &pzErrMsg)) != SQLITE_OK)
    {
        fprintf(stderr, "** db_SAMPLE1: Cannot execute BEGIN statement (%d-%s)\n", ret, pzErrMsg);
        freemem(pzErrMsg);
        return 0;
    }
    
    sprintf(sql, "select key, description, location from SAMPLE1 where key = ?");
    if (sqlite_compile(db_SAMPLE1, sql, 0, &ppVm_SAMPLE1_PRODUCT_CODE, &pzErrMsg) != SQLITE_OK)
    {
        fprintf(stderr, "** Error compiling sql for db_SAMPLE1->SAMPLE1_PRODUCT_CODE (%s)\n", pzErrMsg);
        return 0;
    }
    
    return 1;
}

void SqliteDisconnect ()
{
    sqlite_exec(db_SAMPLE2, "END;", 0, 0, 0);sqlite_close(db_SAMPLE2);
    sqlite_exec(db_SAMPLE1, "END;", 0, 0, 0);sqlite_close(db_SAMPLE1);
}

int readsplit (SV* I_VAL_ref)
{
    char sql[4096];
    int ret;
    char *pzErrMsg = 0;
    register char *p;
    static char inp[GFMAXPIPBUFFER];
    register AV* I_VAL;
    register int i=0;
    
    if (!fgets(inp, GFMAXPIPBUFFER, fstream) ) return 0;
    if (!SvROK(I_VAL_ref)) croak("I_VAL_ref is not a reference");
    
    I_VAL = (AV*)SvRV(I_VAL_ref);
    av_clear(I_VAL);
    
    inp[strlen(inp)-1] = '\0';
    memset(fields, 0, sizeof(fields));
    
    p = inp;
    fields[0] = p;
    while (*p) 
    {
        if (*p == '|') 
        {
            *p = '\0';
            av_store(I_VAL, i, newSVpvn(fields[i], strlen(fields[i])));
            fields[++i] = p + 1;
        }
        
        p++;
    }
    
    av_store(I_VAL, i, newSVpvn(fields[i], strlen(fields[i])));
    while (++i < GFMAXPIPFLDS)
        av_store(I_VAL, i, newSVpvn("", 0));
    int pN;
    static const char **pazValue_SAMPLE2_PRODUCT_CODE;
    static int last_step_SAMPLE2_PRODUCT_CODE = SQLITE_ROW;
    static const char **pazValue_SAMPLE1_PRODUCT_CODE;
//++++++ Table SAMPLE1 (PRODUCT_CODE) --> Type :Pequel::Type::Table::Sqlite ++++++
    sqlite_reset(ppVm_SAMPLE1_PRODUCT_CODE, 0);
    if ((ret = sqlite_bind(ppVm_SAMPLE1_PRODUCT_CODE, 1, fields[_I_PRODUCT_CODE], -1, 0)) != SQLITE_OK)
    {
        fprintf(stderr, "** Error binding to db_SAMPLE1->SAMPLE1_PRODUCT_CODE (%s)\n", sqlite_error_string(ret));
        croak("exiting");
    }
    
    if (sqlite_step(ppVm_SAMPLE1_PRODUCT_CODE, &pN, &pazValue_SAMPLE1_PRODUCT_CODE, 0) == SQLITE_ROW)
    {
        av_store(I_VAL, _I_SAMPLE1_PRODUCT_CODE_FLD_KEY, newSVpvn(pazValue_SAMPLE1_PRODUCT_CODE[0], strlen(pazValue_SAMPLE1_PRODUCT_CODE[0])));
        av_store(I_VAL, _I_SAMPLE1_PRODUCT_CODE_FLD_DESCRIPTION, newSVpvn(pazValue_SAMPLE1_PRODUCT_CODE[1], strlen(pazValue_SAMPLE1_PRODUCT_CODE[1])));
        av_store(I_VAL, _I_SAMPLE1_PRODUCT_CODE_FLD_LOCATION, newSVpvn(pazValue_SAMPLE1_PRODUCT_CODE[2], strlen(pazValue_SAMPLE1_PRODUCT_CODE[2])));
    }
    
//++++++ Table SAMPLE2 (PRODUCT_CODE) --> Type :Pequel::Type::Table::Sqlite::Merge ++++++
    if (pazValue_SAMPLE2_PRODUCT_CODE == 0 && last_step_SAMPLE2_PRODUCT_CODE == SQLITE_ROW)
    {
        last_step_SAMPLE2_PRODUCT_CODE = sqlite_step(ppVm_SAMPLE2_PRODUCT_CODE, &pN, &pazValue_SAMPLE2_PRODUCT_CODE, 0);
    }
    
    while
    (
        last_step_SAMPLE2_PRODUCT_CODE == SQLITE_ROW
        && pazValue_SAMPLE2_PRODUCT_CODE != 0
        && strcmp(fields[_I_PRODUCT_CODE], pazValue_SAMPLE2_PRODUCT_CODE[0]) > 0
        && (last_step_SAMPLE2_PRODUCT_CODE = sqlite_step(ppVm_SAMPLE2_PRODUCT_CODE, &pN, &pazValue_SAMPLE2_PRODUCT_CODE, 0)) == SQLITE_ROW
    )
    
    {
        if (pazValue_SAMPLE2_PRODUCT_CODE == 0) break;
        if (strcmp(fields[_I_PRODUCT_CODE], pazValue_SAMPLE2_PRODUCT_CODE[0]) <= 0) break;
    }
    
    if (pazValue_SAMPLE2_PRODUCT_CODE != 0 && strcmp(fields[_I_PRODUCT_CODE], pazValue_SAMPLE2_PRODUCT_CODE[0]) == 0)
    {
        av_store(I_VAL, _I_SAMPLE2_PRODUCT_CODE_FLD_KEY, newSVpvn(pazValue_SAMPLE2_PRODUCT_CODE[0], strlen(pazValue_SAMPLE2_PRODUCT_CODE[0])));
        av_store(I_VAL, _I_SAMPLE2_PRODUCT_CODE_FLD_DESCRIPTION, newSVpvn(pazValue_SAMPLE2_PRODUCT_CODE[1], strlen(pazValue_SAMPLE2_PRODUCT_CODE[1])));
        av_store(I_VAL, _I_SAMPLE2_PRODUCT_CODE_FLD_LOCATION, newSVpvn(pazValue_SAMPLE2_PRODUCT_CODE[2], strlen(pazValue_SAMPLE2_PRODUCT_CODE[2])));
    }
    
    return 1;
}

int OpenSortStream (int fd)
{
    if ((fstream = fdopen(fd, "r")) == (FILE*)0)
        croak("examples/sqlite_table.pql:Unable to open input file stream.");
    return 1;
}

~; #End of Inline-C Code
