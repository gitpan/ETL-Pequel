// vim: syntax=pequel ts=4 sw=4
//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
//  Script       : all_sections.pql
//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

options
    header                  // (default) write header record to output.
    optimize                // (default) optimize generated code.
    doc_title("All Section Types Example Script")
    doc_email("sample@youraddress.com")
    doc_version(2.4)

description section

init table // Local table:
//  Table-Name  	Key-Value    Field->1
	LOC_DESCRIPT	NSW 		'New South Wales'	
	LOC_DESCRIPT	WA 			'Western Australia'
	LOC_DESCRIPT	SYD 		'Sydney'
	LOC_DESCRIPT	MEL 		'Melbourne'
	LOC_DESCRIPT	SA 			'South Australia'
	LOC_DESCRIPT	NT 			'Northern Territory'
	LOC_DESCRIPT	QLD 		'Queensland'
	LOC_DESCRIPT	VIC 		'Victoria'
	LOC_DESCRIPT	PER 		'Perth'
	LOC_DESCRIPT	ALIC 		'Alice Springs'

load table
	// External embedded table -- key is field-1 (PRODUCT_CODE). 'STRING' is the key-field
	// type. 'sample.data' is the data-source-file to load the table from. Table has two 
	// columns: DESCRIPTION (field #3 in source file), and LOCATION (#8 in source file). 
	// The default for loading an external table is to embedd the table contents in the generated code.
	SAMPLE1 sample.data 1 STRING DESCRIPTION=3 LOCATION=8

load table
	// External dynamic table. The '_' prefix instructs Pequel
	// to load the table dynamically.
	_SAMPLE2 sample.data 1 STRING DESCRIPTION=3 LOCATION=8

load table pequel
	// Data for this table is loaded by executing the Pequel script 'sales_ttl_by_loc.pql'.
	// Pequel tables are loaded dynamically (at runtime).
	// LOCATION is the key field.
	TSALESBYLOC sales_ttl_by_loc.pql LOCATION
	TSALESBYPROD sales_ttl_by_prod.pql PRODUCT_CODE

input section
    PRODUCT_CODE
    COST_PRICE
    DESCRIPTION
    SALES_CODE
	SALES_PRICE
	SALES_QTY
	SALES_DATE
	LOCATION
	S1_DESCRIPTION => %SAMPLE1(PRODUCT_CODE)->DESCRIPTION
	S1_LOCATION => %SAMPLE1(PRODUCT_CODE)->LOCATION
	S2_DESCRIPTION => %SAMPLE2(PRODUCT_CODE)->DESCRIPTION
	S2_LOCATION => %SAMPLE2(PRODUCT_CODE)->LOCATION
	LDESCRIPT => %LOC_DESCRIPT(LOCATION) 
	SALESBYLOC => %TSALESBYLOC(LOCATION)->SALES_TOTAL
	SALESBYPROD => %TSALESBYPROD(PRODUCT_CODE)->SALES_TOTAL

divert input record (diverted_record_low.pql)
	SALES_QTY <= 100000

copy input record (pequel:copy_record_SA.pql)
	LOCATION eq 'SA'

sort by 
	PRODUCT_CODE

group by
	PRODUCT_CODE

field preprocess
	PRODUCT_CODE => &uc(PRODUCT_CODE) 

display message on input ("Product code: PRODUCT_CODE")
	PRODUCT_CODE =~ /^A/

display message on input abort ("Invalid Product Code: PRODUCT_CODE")
	PRODUCT_CODE =~ /^[0-9]/

filter
	PRODUCT_CODE !~ /^Z/

reject
	SALES_QTY == 0

output section
	string PRODUCT_CODE				PRODUCT_CODE,
	numeric RECORD_COUNT 			count *
	numeric SALES_QTY_SAMPLE1 		sum SALES_QTY where exists %SAMPLE1(PRODUCT_CODE) 
	numeric SALES_QTY_SAMPLE2 		sum SALES_QTY where exists %SAMPLE2(PRODUCT_CODE) 
	string S1_DESCRIPTION 			S1_DESCRIPTION
	string S1_LOCATION 				S1_LOCATION
	string S2_DESCRIPTION 			S2_DESCRIPTION
	string S2_LOCATION 				S2_LOCATION
	decimal PRODUCT_SALES_TOTAL 	SALESBYPROD,
	decimal LOCATION_SALES_TOTAL 	SALESBYLOC,

field postprocess
	RECORD_COUNT => &sprintf("%06d", RECORD_COUNT)

display message on output("Product PRODUCT_CODE contains less than 5 transactions -- RECORD_COUNT")
	RECORD_COUNT < 15

display message on output abort("Invalid transaction count for Product PRODUCT_CODE > 500 transactions -- RECORD_COUNT")
	RECORD_COUNT > 500

copy output record (pequel:copy_output_combiner.pql)
	SALES_QTY > 0

sort output
	S2_LOCATION string desc
	
