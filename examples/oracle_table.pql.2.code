#!/usr/bin/perl
#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# vim: syntax=perl ts=4 sw=4
#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#Generated By: pequel Version 2.3-6, Build: Wednesday October  26 23:16:49 BST 2005
#            : http://sourceforge.net/projects/pequel/
#Script Name : examples/oracle_table.pql
#Created On  : Wed Oct 26 14:08:45 2005
#Perl Version: /usr/bin/perl 5.6.1 on solaris
#For         : 
#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#Options:
#prefix(examples) directory pathname prefix.
#dumpcode(1) Dump the generated Perl code for pequel script
#noverbose(1) do not progress counter
#script_name(examples/oracle_table.pql) script filename
#header(1) write header record to output.
#optimize(1) optimize generated code.
#doc_title(Oracle Tables Example Script) document title.
#doc_email(sample@youraddress.com) document email entry.
#doc_version(2.2) document version for pequel script.
#inline_cc(CC) Inline: CC
#inline_force_build(1) Inline: force_build
#inline_optimize(-xO5 -xinline=%auto) Inline: OPTIMIZE
#inline_ccflags(-xchip=ultra3 -DSS_64BIT_SERVER -DBIT64 -DMACHINE64) Inline: CCFLAGS
#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
use strict;
use Fcntl;
use constant _I_PRODUCT_CODE         => int    0;
use constant _I_COST_PRICE           => int    1;
use constant _I_DESCRIPTION          => int    2;
use constant _I_SALES_CODE           => int    3;
use constant _I_SALES_PRICE          => int    4;
use constant _I_SALES_QTY            => int    5;
use constant _I_SALES_DATE           => int    6;
use constant _I_LOCATION             => int    7;
use constant _I_S1_DESCRIPTION       => int    8;
use constant _I_S1_LOCATION          => int    9;
use constant _I_S2_DESCRIPTION       => int   10;
use constant _I_S2_LOCATION          => int   11;
use constant _O_PRODUCT_CODE         => int    1;
use constant _O_RECORD_COUNT         => int    2;
use constant _O_SALES_QTY_SAMPLE1    => int    3;
use constant _O_S1_DESCRIPTION       => int    4;
use constant _O_S1_LOCATION          => int    5;
use constant _O_SALES_QTY_SAMPLE2    => int    6;
use constant _O_S2_DESCRIPTION       => int    7;
use constant _O_S2_LOCATION          => int    8;
use constant _T_SAMPLE2_FLD_DESCRIPTION   => int    0;
use constant _T_SAMPLE2_FLD_LOCATION      => int    1;
use constant _T_SAMPLE1_FLD_DESCRIPTION   => int    0;
use constant _T_SAMPLE1_FLD_LOCATION      => int    1;
use constant _I_SAMPLE1_PRODUCT_CODE_FLD_KEY          => int   12;
use constant _I_SAMPLE1_PRODUCT_CODE_FLD_DESCRIPTION  => int   13;
use constant _I_SAMPLE1_PRODUCT_CODE_FLD_LOCATION     => int   14;
use constant _I_SAMPLE2_PRODUCT_CODE_FLD_KEY          => int   15;
use constant _I_SAMPLE2_PRODUCT_CODE_FLD_DESCRIPTION  => int   16;
use constant _I_SAMPLE2_PRODUCT_CODE_FLD_LOCATION     => int   17;
local $\="\n";
local $,="|";
use constant LAST_ICELL => int 11;
my @I_VAL;
my @O_VAL;
my $key__I_PRODUCT_CODE;
my $previous_key__I_PRODUCT_CODE = undef;
foreach my $f (1..8) { $O_VAL[$f] = undef; }
&LoadTableSAMPLE2; # Create database for SAMPLE2
&LoadTableSAMPLE1; # Create database for SAMPLE1
# Sort:PRODUCT_CODE(asc:string) 
open(DATA, q{cat  - | sort  -t'|' -y -k 1,1 2>/dev/null |}) || die "Cannot open input: $!";
my $fd = fileno(DATA);
OpenSortStream($fd);
&PrintHeader();
OracleConnect($fd);
my $i;
while (readsplit(\@I_VAL))
{
    ++$i;
    $key__I_PRODUCT_CODE = $I_VAL[_I_PRODUCT_CODE];
    if (!defined($previous_key__I_PRODUCT_CODE))
    {
        $previous_key__I_PRODUCT_CODE = $key__I_PRODUCT_CODE;
    }
    
    elsif ($previous_key__I_PRODUCT_CODE ne $key__I_PRODUCT_CODE)
    {
        print STDOUT
            $O_VAL[_O_PRODUCT_CODE],
            $O_VAL[_O_RECORD_COUNT],
            $O_VAL[_O_SALES_QTY_SAMPLE1],
            $O_VAL[_O_S1_DESCRIPTION],
            $O_VAL[_O_S1_LOCATION],
            $O_VAL[_O_SALES_QTY_SAMPLE2],
            $O_VAL[_O_S2_DESCRIPTION],
            $O_VAL[_O_S2_LOCATION]
        ;
        $previous_key__I_PRODUCT_CODE = $key__I_PRODUCT_CODE;
        @O_VAL = undef;
    }
    
    $O_VAL[_O_PRODUCT_CODE] = $I_VAL[_I_PRODUCT_CODE];
    $O_VAL[_O_RECORD_COUNT]++;
    $I_VAL[_I_S1_DESCRIPTION] = $I_VAL[_I_SAMPLE1_PRODUCT_CODE_FLD_DESCRIPTION];
    $O_VAL[_O_S1_DESCRIPTION] = $I_VAL[_I_S1_DESCRIPTION];
    $I_VAL[_I_S1_LOCATION] = $I_VAL[_I_SAMPLE1_PRODUCT_CODE_FLD_LOCATION];
    $O_VAL[_O_S1_LOCATION] = $I_VAL[_I_S1_LOCATION];
    $I_VAL[_I_S2_DESCRIPTION] = $I_VAL[_I_SAMPLE2_PRODUCT_CODE_FLD_DESCRIPTION];
    $O_VAL[_O_S2_DESCRIPTION] = $I_VAL[_I_S2_DESCRIPTION];
    $I_VAL[_I_S2_LOCATION] = $I_VAL[_I_SAMPLE2_PRODUCT_CODE_FLD_LOCATION];
    $O_VAL[_O_S2_LOCATION] = $I_VAL[_I_S2_LOCATION];
    
    if (exists $I_VAL[_I_SAMPLE1_PRODUCT_CODE_FLD_KEY] ne '') {
        $O_VAL[_O_SALES_QTY_SAMPLE1] += $I_VAL[_I_SALES_QTY] unless ($I_VAL[_I_SALES_QTY] eq '');
    }
    
    if (exists $I_VAL[_I_SAMPLE2_PRODUCT_CODE_FLD_KEY] ne '') {
        $O_VAL[_O_SALES_QTY_SAMPLE2] += $I_VAL[_I_SALES_QTY] unless ($I_VAL[_I_SALES_QTY] eq '');
    }
}

print STDOUT
    $O_VAL[_O_PRODUCT_CODE],
    $O_VAL[_O_RECORD_COUNT],
    $O_VAL[_O_SALES_QTY_SAMPLE1],
    $O_VAL[_O_S1_DESCRIPTION],
    $O_VAL[_O_S1_LOCATION],
    $O_VAL[_O_SALES_QTY_SAMPLE2],
    $O_VAL[_O_S2_DESCRIPTION],
    $O_VAL[_O_S2_LOCATION]
;
OracleDisconnect();
#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#++++++ Table SAMPLE1 --> Type :Pequel::Type::Table::Oracle ++++++
sub LoadTableSAMPLE1
{
    my %_TABLE_SAMPLE1;
    use DBI;
    my $password = 'passwd';
    if ($password eq '')
    {
        $password = `grep -iw DB1 \$HOME/.password | grep -iw user | awk '{ print \$3 }'`;
        chomp($password);
    }
    
    my $dbh = DBI->connect
    (
        'dbi:Oracle:DB1', 'user', $password, 
        { RowCacheSize => 5000, RaiseError => 0, AutoCommit => 0 }
    )
    
    or die "Cannot connect to DB1:$!";
    $dbh->{PrintError} = 0;
    my @tables = $dbh->tables();
    map(s/\"//g, @tables);
    my $table_exists = grep(m/\.SAMPLE1$/i, @tables);
    if (!$table_exists)
    {
        my @flist =
        (
            'key',
            'description',
            'location'
        );
        
        my %flist =
        (
            key => 'STRING(12) PRIMARY KEY',
            description => 'varchar2(128)',
            location => 'varchar2(128)'
        );
        
        $dbh->do("CREATE TABLE SAMPLE1 ( @{[ join(',', map(qq{$_ $flist{$_}}, @flist)) ]} )");
        $dbh->commit or die $dbh->errstr;
        open(CTL, '>examples/_TABLE_SAMPLE1.oracle.ctl');
        print CTL "LOAD";
        print CTL "append into table SAMPLE1";
        print CTL "FIELDS TERMINATED BY '|' TRAILING NULLCOLS";
        print CTL "(";
        print CTL "@{[ join(qq{,\n}, @flist) ]}";
        print CTL ")";
        close(CTL);
        system("sort  -u -t'|' -k 1 | cut -d'|' -f1,3,8  sample.data > examples/_TABLE_SAMPLE1.oracle.dat");
        my $sqlldr =
            'control=examples/_TABLE_SAMPLE1.oracle.ctl '
            . 'direct=true '
            . 'data=examples/_TABLE_SAMPLE1.oracle.dat '
            . 'bad=examples/_TABLE_SAMPLE1.oracle.bad '
            . 'log=examples/_TABLE_SAMPLE1.oracle.log '
            . 'rows=100000';
        open(SQLLDR, ">examples/_TABLE_SAMPLE1.oracle.sqlldr");
        print SQLLDR "UID=user; export UID";
        ($password eq '')
            ? print SQLLDR "PWD=`grep -iw DB1 \$HOME/.password | grep -iw user | awk '{ print \$3 }'`; export PWD"
            : print SQLLDR "PWD=$password; export PWD";
        print SQLLDR "DB=DB1; export DB";
        print SQLLDR "sqlldr $sqlldr <<EOF";
        print SQLLDR "\$UID/\$PWD\@\$DB";
        print SQLLDR "EOF";
        close(SQLLDR);
        system("sh examples/_TABLE_SAMPLE1.oracle.sqlldr 2>&1 >examples/_TABLE_SAMPLE1.oracle.err");
    }
    
    my $sth = $dbh->prepare("SELECT count(1) FROM SAMPLE1");
    $sth->execute;
    my $loaded = $sth->fetchrow_array;
    $sth->finish;
    $dbh->disconnect;
}

#++++++ Table SAMPLE2 --> Type :Pequel::Type::Table::Oracle::Merge ++++++
sub LoadTableSAMPLE2
{
    my %_TABLE_SAMPLE2;
    use DBI;
    my $password = 'passwd';
    if ($password eq '')
    {
        $password = `grep -iw DB1 \$HOME/.password | grep -iw user | awk '{ print \$3 }'`;
        chomp($password);
    }
    
    my $dbh = DBI->connect
    (
        'dbi:Oracle:DB1', 'user', $password, 
        { RowCacheSize => 5000, RaiseError => 0, AutoCommit => 0 }
    )
    
    or die "Cannot connect to DB1:$!";
    $dbh->{PrintError} = 0;
    my @tables = $dbh->tables();
    map(s/\"//g, @tables);
    my $table_exists = grep(m/\.SAMPLE2$/i, @tables);
    if (!$table_exists)
    {
        my @flist =
        (
            'key',
            'description',
            'location'
        );
        
        my %flist =
        (
            key => 'STRING(12) ',
            description => 'varchar2(128)',
            location => 'varchar2(128)'
        );
        
        $dbh->do("CREATE TABLE SAMPLE2 ( @{[ join(',', map(qq{$_ $flist{$_}}, @flist)) ]} )");
        $dbh->commit or die $dbh->errstr;
        open(CTL, '>examples/_TABLE_SAMPLE2.oracle.ctl');
        print CTL "LOAD";
        print CTL "append into table SAMPLE2";
        print CTL "FIELDS TERMINATED BY '|' TRAILING NULLCOLS";
        print CTL "(";
        print CTL "@{[ join(qq{,\n}, @flist) ]}";
        print CTL ")";
        close(CTL);
        system("sort  -u -t'|' -k 1 | cut -d'|' -f1,3,8  sample.data > examples/_TABLE_SAMPLE2.oracle.dat");
        my $sqlldr =
            'control=examples/_TABLE_SAMPLE2.oracle.ctl '
            . 'direct=true '
            . 'data=examples/_TABLE_SAMPLE2.oracle.dat '
            . 'bad=examples/_TABLE_SAMPLE2.oracle.bad '
            . 'log=examples/_TABLE_SAMPLE2.oracle.log '
            . 'rows=100000';
        open(SQLLDR, ">examples/_TABLE_SAMPLE2.oracle.sqlldr");
        print SQLLDR "UID=user; export UID";
        ($password eq '')
            ? print SQLLDR "PWD=`grep -iw DB1 \$HOME/.password | grep -iw user | awk '{ print \$3 }'`; export PWD"
            : print SQLLDR "PWD=$password; export PWD";
        print SQLLDR "DB=DB1; export DB";
        print SQLLDR "sqlldr $sqlldr <<EOF";
        print SQLLDR "\$UID/\$PWD\@\$DB";
        print SQLLDR "EOF";
        close(SQLLDR);
        system("sh examples/_TABLE_SAMPLE2.oracle.sqlldr 2>&1 >examples/_TABLE_SAMPLE2.oracle.err");
    }
    
    my $sth = $dbh->prepare("SELECT count(1) FROM SAMPLE2");
    $sth->execute;
    my $loaded = $sth->fetchrow_array;
    $sth->finish;
    $dbh->disconnect;
}

sub PrintHeader
{
    local $\="\n";
    local $,="|";
    print 
        'PRODUCT_CODE',
        'RECORD_COUNT',
        'SALES_QTY_SAMPLE1',
        'S1_DESCRIPTION',
        'S1_LOCATION',
        'SALES_QTY_SAMPLE2',
        'S2_DESCRIPTION',
        'S2_LOCATION'
        ;
}

#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#***** I N L I N E *****
use Inline
    C => Config =>
    NAME => 'examples::oracle_table',
    CC => 'CC',
    CLEAN_AFTER_BUILD => '1',
    CLEAN_BUILD_AREA => '1',
    PRINT_INFO => '0',
    BUILD_NOISY => '0',
    BUILD_TIMERS => '0',
    FORCE_BUILD => '1',
    LIBS => '  -L/opt/app/oracle/product/9.2.0/lib -L/opt/app/oracle/product/9.2.0/rdbms/lib -lpthread -lclntsh -lc',
    INC => '  -I/opt/app/oracle/product/9.2.0/rdbms/demo -I/opt/app/oracle/product/9.2.0/rdbms/public',
    CCFLAGS => '-xchip=ultra3 -DSS_64BIT_SERVER -DBIT64 -DMACHINE64  ',
    OPTIMIZE => '-xO5 -xinline=%auto  '
    ;

use Inline C => q~

#include <oci.h>

#define GFMAXPIPBUFFER      3072
#define GFMAXPIPFLDS        13

#define _I_PRODUCT_CODE            0
#define _I_COST_PRICE              1
#define _I_DESCRIPTION             2
#define _I_SALES_CODE              3
#define _I_SALES_PRICE             4
#define _I_SALES_QTY               5
#define _I_SALES_DATE              6
#define _I_LOCATION                7
#define _I_S1_DESCRIPTION          8
#define _I_S1_LOCATION             9
#define _I_S2_DESCRIPTION         10
#define _I_S2_LOCATION            11

#define _I_SAMPLE1_PRODUCT_CODE_FLD_KEY            12
#define _I_SAMPLE1_PRODUCT_CODE_FLD_DESCRIPTION    13
#define _I_SAMPLE1_PRODUCT_CODE_FLD_LOCATION       14
#define _I_SAMPLE2_PRODUCT_CODE_FLD_KEY            15
#define _I_SAMPLE2_PRODUCT_CODE_FLD_DESCRIPTION    16
#define _I_SAMPLE2_PRODUCT_CODE_FLD_LOCATION       17


int oracle_open_all();
int oracle_prep_all();

sword status;
text errbuf[512];
sb4 errcode =0;

#define STD_FLD_LEN 128
#define _OracleMergeFetchNumeric(tbl,ikey) \
    if (tbl##_KEY == 0 && last_step_##tbl == OCI_SUCCESS) \
    { \
        last_step_##tbl = OCIStmtFetch(stmthp_##tbl, errhp, (ub4) 1, (ub4) OCI_FETCH_NEXT, (ub4) OCI_DEFAULT); \
    } \
    while \
    ( \
        last_step_##tbl == OCI_SUCCESS \
        && tbl##_KEY != 0 \
        && atol(fields[ikey]) > tbl##_KEY \
        && (last_step_##tbl = OCIStmtFetch(stmthp_##tbl, errhp, (ub4) 1, (ub4) OCI_FETCH_NEXT, (ub4) OCI_DEFAULT)) == OCI_SUCCESS \
    ) \
    { \
        if (tbl##_KEY == 0) break; \
        if (atol(fields[ikey]) <= tbl##_KEY) break; \
    } \
    if (tbl##_KEY != 0 && atol(fields[ikey]) == tbl##_KEY)

#define _OracleMergeFetchString(tbl,ikey) \
    if (tbl##_KEY == 0 && last_step_##tbl == OCI_SUCCESS) \
    { \
        last_step_##tbl = OCIStmtFetch(stmthp_##tbl, errhp, (ub4) 1, (ub4) OCI_FETCH_NEXT, (ub4) OCI_DEFAULT); \
    } \
    while \
    ( \
        last_step_##tbl == OCI_SUCCESS \
        && tbl##_KEY != 0 \
        && strcmp(fields[ikey], (const char*)tbl##_KEY) > 0 \
        && (last_step_##tbl = OCIStmtFetch(stmthp_##tbl, errhp, (ub4) 1, (ub4) OCI_FETCH_NEXT, (ub4) OCI_DEFAULT)) == OCI_SUCCESS \
    ) \
    { \
        if (tbl##_KEY == 0) break; \
        if (strcmp(fields[ikey], (const char*)tbl##_KEY) <= 0) break; \
    } \
    if (tbl##_KEY != 0 && strcmp(fields[ikey], (const char*)tbl##_KEY) == 0)

#define _av_store_numeric(tbl,fld) \
    if (!indicator_##tbl##_##fld) \
        av_store(I_VAL, _I_##tbl##_FLD_##fld, newSVpvf("%ld", tbl##_##fld));

#define _av_store_string(tbl,fld) \
    if (!indicator_##tbl##_##fld) \
        av_store(I_VAL, _I_##tbl##_FLD_##fld, newSVpvf("%s", tbl##_##fld));

static OCIEnv* envhp = (OCIEnv*)0; // environment handle
static OCIError* errhp = (OCIError*)0; // error handle
static OCISvcCtx* svchp_DB1 = (OCISvcCtx*)0; // service context handle
static OCIServer* srvhp_DB1 = (OCIServer*)0; // server handle
static OCISession* authp_DB1 = (OCISession*)0; // user session (authentication) handle

static OCIStmt* stmthp_SAMPLE2_PRODUCT_CODE = (OCIStmt*)0;
static OCIDefine* define_SAMPLE2_PRODUCT_CODE_KEY = (OCIDefine*)0;
static sb2 indicator_SAMPLE2_PRODUCT_CODE_KEY;
static text SAMPLE2_PRODUCT_CODE_KEY[STD_FLD_LEN];
static text SAMPLE2_PRODUCT_CODE_DESCRIPTION[STD_FLD_LEN];
static OCIDefine* define_SAMPLE2_PRODUCT_CODE_DESCRIPTION = (OCIDefine*)0;
static sb2 indicator_SAMPLE2_PRODUCT_CODE_DESCRIPTION;
static text SAMPLE2_PRODUCT_CODE_LOCATION[STD_FLD_LEN];
static OCIDefine* define_SAMPLE2_PRODUCT_CODE_LOCATION = (OCIDefine*)0;
static sb2 indicator_SAMPLE2_PRODUCT_CODE_LOCATION;

static OCIStmt* stmthp_SAMPLE1_PRODUCT_CODE = (OCIStmt*)0;
static OCIBind* bndhp_SAMPLE1_PRODUCT_CODE = (OCIBind*)0;
static OCIDefine* define_SAMPLE1_PRODUCT_CODE_KEY = (OCIDefine*)0;
static sb2 indicator_SAMPLE1_PRODUCT_CODE_KEY;
static text SAMPLE1_PRODUCT_CODE_KEY[STD_FLD_LEN];
static text SAMPLE1_PRODUCT_CODE_DESCRIPTION[STD_FLD_LEN];
static OCIDefine* define_SAMPLE1_PRODUCT_CODE_DESCRIPTION = (OCIDefine*)0;
static sb2 indicator_SAMPLE1_PRODUCT_CODE_DESCRIPTION;
static text SAMPLE1_PRODUCT_CODE_LOCATION[STD_FLD_LEN];
static OCIDefine* define_SAMPLE1_PRODUCT_CODE_LOCATION = (OCIDefine*)0;
static sb2 indicator_SAMPLE1_PRODUCT_CODE_LOCATION;

static const char *fields[GFMAXPIPFLDS];
static FILE *fstream = (FILE*)0;

int OracleConnect (int fd)
{
    oracle_open_all();
    oracle_prep_all();
    fstream = fdopen(fd, "r");
    return 1;
}


void oracle_checkerr(OCIError *errhp, sword status, text *msg)
{
    text errbuf[512];
    sb4 errcode = 0;
    
    switch (status)
    {
        case OCI_SUCCESS:
            break;
        case OCI_SUCCESS_WITH_INFO:
            (void) fprintf(stderr, "** Oracle Error - OCI_SUCCESS_WITH_INFO\n");
            break;
        case OCI_NEED_DATA:
            (void) fprintf(stderr, "** Oracle Error - OCI_NEED_DATA\n");
            break;
        case OCI_NO_DATA:
            (void) fprintf(stderr, "** Oracle Error - OCI_NODATA\n");
            break;
        case OCI_ERROR:
            (void) OCIErrorGet((dvoid *)errhp, (ub4) 1, (text *) NULL,&errcode,errbuf, (ub4) sizeof(errbuf), OCI_HTYPE_ERROR);
            (void) fprintf(stderr, "** Oracle Error - %s - %.*s\n", msg, 512, errbuf);
            break;
        case OCI_INVALID_HANDLE:
            (void) fprintf(stderr, "** Oracle Error - OCI_INVALID_HANDLE\n");
            break;
        case OCI_STILL_EXECUTING:
            (void) fprintf(stderr, "** Oracle Error - OCI_STILL_EXECUTE\n");
            break;
        case OCI_CONTINUE:
            (void) fprintf(stderr, "** Oracle Error - OCI_CONTINUE\n");
            break;
        default:
            break;
    }
    
}


int oracle_open_all ()
{
    
    ub4 init_mode = OCI_DEFAULT;	// or OCI_OBJECT
    ub4 credt = OCI_CRED_RDBMS;
    sword status;

    // initialize OCI and set up handles
    if
    (
        OCIInitialize
        (
            OCI_THREADED, (dvoid*)0,
            (dvoid* (*)(dvoid*, size_t))0,
            (dvoid* (*)(dvoid*, dvoid*, size_t))0,
            (void (*)(dvoid*, dvoid*))0
        ) != OCI_SUCCESS
    )
    {
        fprintf(stderr, "ERROR: failed to initialize OCI\n");
        exit(1);
    }
    //  

    if ((status = OCIEnvInit(&envhp, OCI_DEFAULT, (size_t)0, (dvoid**)0)) != OCI_SUCCESS)
    {
        oracle_checkerr(errhp, status, (text*)"Unable to initialize environment handle");
        exit(1);
    }
    //  

    if 
    (
        (status = OCIHandleAlloc(envhp, 
        (dvoid**)&errhp, OCI_HTYPE_ERROR, 
        (size_t)0, (dvoid**)0)) != OCI_SUCCESS
    )
    {
        oracle_checkerr(errhp, status, (text*)"Unable to allocate error handle");
    }
    //  
		
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//++++++ Db DB1 --> Type :Pequel::Type::Db::Oracle::Element ++++++
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
    text* username_DB1 = (text*)"user";
    text* password_DB1 = (text*)"passwd";
    text* server_DB1 = (text*)"DB1";

    if 
    (
        (status = OCIHandleAlloc(envhp, 
        (dvoid**)&authp_DB1, OCI_HTYPE_SESSION, 
        (size_t)0, (dvoid**)0)) != OCI_SUCCESS
    )
    {
        oracle_checkerr(errhp, status, (text*)"Unable to allocate authenication handle");
    }
    //	

    // attach server
    if 
    (
        (status = OCIHandleAlloc(envhp, 
        (dvoid**)&srvhp_DB1, OCI_HTYPE_SERVER, 
        (size_t)0, (dvoid**)0)) != OCI_SUCCESS
    )
    {
        oracle_checkerr(errhp, status, (text*)"Unable to allocate server handle");
    }
    //	

    if 
    (
        (status = OCIServerAttach(srvhp_DB1, 
        errhp, 
        server_DB1, 
        (sb4)strlen((char*)server_DB1), OCI_DEFAULT)) != OCI_SUCCESS
    )
    {
        oracle_checkerr(errhp, status, (text*)"Unable to attach server");
    //  fprintf(stderr, "Error (%d): Unable to attach server '%s'\n", status, (const char*)server_DB1);
    }
    //  

    if 
    (
        (status = OCIHandleAlloc(envhp, 
        (dvoid**)&svchp_DB1, OCI_HTYPE_SVCCTX, 
        (size_t)0, (dvoid**)0)) != OCI_SUCCESS
    )
    {
        oracle_checkerr(errhp, status, (text*)"Unable to allocate service handle");
    }
    //  

    if 
    (
        (status = OCIAttrSet(svchp_DB1, OCI_HTYPE_SVCCTX, 
        (dvoid*)srvhp_DB1, (ub4)0, OCI_ATTR_SERVER, 
        errhp)) != OCI_SUCCESS
    )
    {
        oracle_checkerr(errhp, status, (text*)"Unable to set server handle in service handle");
    }
    //  

    // log on
    if 
    (
        (status = OCIAttrSet(authp_DB1, OCI_HTYPE_SESSION, 
        (dvoid*)username_DB1, 
        (ub4)strlen((char*)username_DB1), OCI_ATTR_USERNAME, 
        errhp)) != OCI_SUCCESS
    )
    {
        oracle_checkerr(errhp, status, (text*)"Unable to set username as attributes on authentication handle");
    }
    if 
    (
        (status = OCIAttrSet(authp_DB1, OCI_HTYPE_SESSION, 
        (dvoid*)password_DB1, 
        (ub4)strlen((char*)password_DB1), OCI_ATTR_PASSWORD, 
        errhp)) != OCI_SUCCESS
    )
    {
        oracle_checkerr(errhp, status, (text*)"Unable to set password as attributes on authentication handle");
    }
    //  

    if 
    (
        (status = OCISessionBegin(svchp_DB1, 
        errhp, 
        authp_DB1, 
        credt, OCI_DEFAULT)) != OCI_SUCCESS
    )
    {
        oracle_checkerr(errhp, status, (text*)"Unable to log on");
    //  fprintf(stderr, "Error (%d): Unable to log on as '%s'\n", status, (const char*)username_DB1);
    }
    //  

    if 
    (
        (status = OCIAttrSet(svchp_DB1, OCI_HTYPE_SVCCTX, 
        (dvoid*)authp_DB1, (ub4)0, OCI_ATTR_SESSION, 
        errhp)) != OCI_SUCCESS
    )
    {
        oracle_checkerr(errhp, status, (text*)"Unable to set authentication handle in service handle");
    }
    //  
		
    return 1;
}

int oracle_prep_all ()
{
    ub4 prefetch = 100;
    sword status;
    
//++++++ Table SAMPLE2 --> Type :Pequel::Type::Table::Oracle::Merge ++++++
    if ((status = OCIHandleAlloc(envhp, (dvoid **)&stmthp_SAMPLE2_PRODUCT_CODE, OCI_HTYPE_STMT, 0, 0)) != OCI_SUCCESS)
    {
        oracle_checkerr(errhp, status, (text*)"allocate statement handle SAMPLE2_PRODUCT_CODE");
    }
    text *sql_SAMPLE2_PRODUCT_CODE = (text*)"select key, description, location from SAMPLE2 FULL";
    if ((status = OCIStmtPrepare(stmthp_SAMPLE2_PRODUCT_CODE, errhp, sql_SAMPLE2_PRODUCT_CODE, 
        strlen((const char*)sql_SAMPLE2_PRODUCT_CODE), OCI_NTV_SYNTAX, 0)) != OCI_SUCCESS)
    {
        oracle_checkerr(errhp, status, (text*)"prepare statement SAMPLE2_PRODUCT_CODE");
    }
    if ((status = OCIAttrSet(stmthp_SAMPLE2_PRODUCT_CODE, OCI_HTYPE_STMT, &prefetch, (ub4)0, OCI_ATTR_PREFETCH_ROWS, errhp)) != OCI_SUCCESS)
    {
        oracle_checkerr(errhp, status, (text*)"prefetch attribute SAMPLE2_PRODUCT_CODE");
    }
    if ((status = OCIStmtExecute(svchp_DB1, stmthp_SAMPLE2_PRODUCT_CODE, errhp, 
        (ub4)0, (ub4)0, (CONST OCISnapshot*)NULL, (OCISnapshot*)NULL, OCI_DEFAULT)) != OCI_SUCCESS)
    {
        oracle_checkerr(errhp, status, (text*)"execute statement SAMPLE2_PRODUCT_CODE");
    }
    if ((status = OCIDefineByPos(stmthp_SAMPLE2_PRODUCT_CODE, &define_SAMPLE2_PRODUCT_CODE_KEY, errhp, 
        (ub4)1, SAMPLE2_PRODUCT_CODE_KEY, STD_FLD_LEN+1, (ub2)SQLT_STR, 
        (void*)&indicator_SAMPLE2_PRODUCT_CODE_KEY, 0, 0, OCI_DEFAULT)) != OCI_SUCCESS)
    {
        oracle_checkerr(errhp, status, (text*)"define SAMPLE2_PRODUCT_CODE_KEY");
    }
    if ((status = OCIDefineByPos(stmthp_SAMPLE2_PRODUCT_CODE, &define_SAMPLE2_PRODUCT_CODE_DESCRIPTION, errhp, 
        (ub4)2, SAMPLE2_PRODUCT_CODE_DESCRIPTION, STD_FLD_LEN+1, (ub2)SQLT_STR, 
        (void*)&indicator_SAMPLE2_PRODUCT_CODE_DESCRIPTION, 0, 0, OCI_DEFAULT)) != OCI_SUCCESS)
    {
        oracle_checkerr(errhp, status, (text*)"define SAMPLE2_PRODUCT_CODE_DESCRIPTION");
    }
    if ((status = OCIDefineByPos(stmthp_SAMPLE2_PRODUCT_CODE, &define_SAMPLE2_PRODUCT_CODE_LOCATION, errhp, 
        (ub4)3, SAMPLE2_PRODUCT_CODE_LOCATION, STD_FLD_LEN+1, (ub2)SQLT_STR, 
        (void*)&indicator_SAMPLE2_PRODUCT_CODE_LOCATION, 0, 0, OCI_DEFAULT)) != OCI_SUCCESS)
    {
        oracle_checkerr(errhp, status, (text*)"define SAMPLE2_PRODUCT_CODE_LOCATION");
    }
    
//++++++ Table SAMPLE1 --> Type :Pequel::Type::Table::Oracle ++++++
    if ((status = OCIHandleAlloc(envhp, (dvoid **)&stmthp_SAMPLE1_PRODUCT_CODE, OCI_HTYPE_STMT, 0, 0)) != OCI_SUCCESS)
    {
        oracle_checkerr(errhp, status, (text*)"allocate statement handle SAMPLE1_PRODUCT_CODE");
    }
    text *sql_SAMPLE1_PRODUCT_CODE = (text*)"select key, description, location from SAMPLE1 where key = :key";
    if ((status = OCIStmtPrepare(stmthp_SAMPLE1_PRODUCT_CODE, errhp, sql_SAMPLE1_PRODUCT_CODE, 
        strlen((const char*)sql_SAMPLE1_PRODUCT_CODE), OCI_NTV_SYNTAX, 0)) != OCI_SUCCESS)
    {
        oracle_checkerr(errhp, status, (text*)"prepare statement SAMPLE1_PRODUCT_CODE");
    }
    if ((status = OCIDefineByPos(stmthp_SAMPLE1_PRODUCT_CODE, &define_SAMPLE1_PRODUCT_CODE_KEY, errhp, 
        (ub4)1, SAMPLE1_PRODUCT_CODE_KEY, STD_FLD_LEN+1, (ub2)SQLT_STR, 
        (void*)&indicator_SAMPLE1_PRODUCT_CODE_KEY, 0, 0, OCI_DEFAULT)) != OCI_SUCCESS)
    {
        oracle_checkerr(errhp, status, (text*)"define SAMPLE1_PRODUCT_CODE_KEY");
    }
    if ((status = OCIDefineByPos(stmthp_SAMPLE1_PRODUCT_CODE, &define_SAMPLE1_PRODUCT_CODE_DESCRIPTION, errhp, 
        (ub4)2, SAMPLE1_PRODUCT_CODE_DESCRIPTION, STD_FLD_LEN+1, (ub2)SQLT_STR, 
        (void*)&indicator_SAMPLE1_PRODUCT_CODE_DESCRIPTION, 0, 0, OCI_DEFAULT)) != OCI_SUCCESS)
    {
        oracle_checkerr(errhp, status, (text*)"define SAMPLE1_PRODUCT_CODE_DESCRIPTION");
    }
    if ((status = OCIDefineByPos(stmthp_SAMPLE1_PRODUCT_CODE, &define_SAMPLE1_PRODUCT_CODE_LOCATION, errhp, 
        (ub4)3, SAMPLE1_PRODUCT_CODE_LOCATION, STD_FLD_LEN+1, (ub2)SQLT_STR, 
        (void*)&indicator_SAMPLE1_PRODUCT_CODE_LOCATION, 0, 0, OCI_DEFAULT)) != OCI_SUCCESS)
    {
        oracle_checkerr(errhp, status, (text*)"define SAMPLE1_PRODUCT_CODE_LOCATION");
    }
    return 1;
}

void OracleDisconnect ()
{
    OCIHandleFree((dvoid *)stmthp_SAMPLE2_PRODUCT_CODE, (ub4)OCI_HTYPE_STMT);
    OCIHandleFree((dvoid *)stmthp_SAMPLE1_PRODUCT_CODE, (ub4)OCI_HTYPE_STMT);
    OCISessionEnd(svchp_DB1, errhp, authp_DB1, (ub4)OCI_DEFAULT);
    OCIServerDetach(srvhp_DB1, errhp, (ub4)OCI_DEFAULT );
    OCIHandleFree((dvoid *)authp_DB1, (ub4)OCI_HTYPE_SESSION);
    OCIHandleFree((dvoid *)srvhp_DB1, (ub4)OCI_HTYPE_SERVER);
    OCIHandleFree((dvoid *)svchp_DB1, (ub4)OCI_HTYPE_SVCCTX);
    OCIHandleFree((dvoid *)errhp, (ub4)OCI_HTYPE_ERROR);
    OCIHandleFree((dvoid *)envhp, (ub4)OCI_HTYPE_ENV);
}

int readsplit (SV* I_VAL_ref)
{
    char sql[4096];
    int ret;
    char *pzErrMsg = 0;
    register char *p;
    static char inp[GFMAXPIPBUFFER];
    register AV* I_VAL;
    register int i=0;
    
    if (!fgets(inp, GFMAXPIPBUFFER, fstream) ) return 0;
    if (!SvROK(I_VAL_ref)) croak("I_VAL_ref is not a reference");
    
    I_VAL = (AV*)SvRV(I_VAL_ref);
    av_clear(I_VAL);
    
    inp[strlen(inp)-1] = '\0';
    memset(fields, 0, sizeof(fields));
    
    p = inp;
    fields[0] = p;
    while (*p) 
    {
        if (*p == '|') 
        {
            *p = '\0';
            av_store(I_VAL, i, newSVpvn(fields[i], strlen(fields[i])));
            fields[++i] = p + 1;
        }
        
        p++;
    }
    
    av_store(I_VAL, i, newSVpvn(fields[i], strlen(fields[i])));
    while (++i < GFMAXPIPFLDS)
        av_store(I_VAL, i, newSVpvn("", 0));
    int pN;
    ub4 prefetch = 100;
    static int last_step_SAMPLE2_PRODUCT_CODE = OCI_SUCCESS;
//++++++ Table SAMPLE1 (PRODUCT_CODE) --> Type :Pequel::Type::Table::Oracle ++++++
    if ((status = OCIBindByPos(stmthp_SAMPLE1_PRODUCT_CODE, &bndhp_SAMPLE1_PRODUCT_CODE, errhp, (ub4)1,
        (dvoid *)fields[_I_PRODUCT_CODE], (sb4)strlen(fields[_I_PRODUCT_CODE])+1, SQLT_STR, 
        (dvoid *)0, (ub2 *)0, (ub2 *)0, (ub4)0, (ub4 *)0, (ub4)OCI_DEFAULT)) != OCI_SUCCESS)
    {
        (void) OCIErrorGet(errhp, (ub4)1, (text *)NULL, &errcode, errbuf, (ub4) sizeof(errbuf), OCI_HTYPE_ERROR);
        oracle_checkerr(errhp, status, (text*)"bind SAMPLE1_PRODUCT_CODE");
    }
    if (OCIStmtExecute(svchp_DB1, stmthp_SAMPLE1_PRODUCT_CODE, errhp, (ub4) 1, 
        (ub4) 0, (CONST OCISnapshot *) NULL, (OCISnapshot *) NULL, OCI_DEFAULT) == OCI_SUCCESS)
    {
        _av_store_string(SAMPLE1_PRODUCT_CODE, KEY);
        _av_store_string(SAMPLE1_PRODUCT_CODE, DESCRIPTION);
        _av_store_string(SAMPLE1_PRODUCT_CODE, LOCATION);
    }
    
//++++++ Table SAMPLE2 (PRODUCT_CODE) --> Type :Pequel::Type::Table::Oracle::Merge ++++++
    _OracleMergeFetchString(SAMPLE2_PRODUCT_CODE,_I_PRODUCT_CODE)
    {
        _av_store_string(SAMPLE2_PRODUCT_CODE, KEY);
        _av_store_string(SAMPLE2_PRODUCT_CODE, DESCRIPTION);
        _av_store_string(SAMPLE2_PRODUCT_CODE, LOCATION);
    }
    
    return 1;
}

int OpenSortStream (int fd)
{
    if ((fstream = fdopen(fd, "r")) == (FILE*)0)
        croak("examples/oracle_table.pql:Unable to open input file stream.");
    return 1;
}

~; #End of Inline-C Code
